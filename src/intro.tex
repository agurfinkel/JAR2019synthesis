
\section{Introduction}

Program synthesis is one of the most challenging problems in computer science. The objective is to define a process to automatically derive implementations that are guaranteed to comply with specifications expressed in the form of logic formulas. The problem has seen increased popularity in the recent years, mainly due to the capabilities of modern symbolic solvers, including Satisfiability Modulo Theories (SMT)~\cite{BarFT-SMTLIB} tools, to compute compact and precise regions that describe under which conditions an implementation exists for the given specification~\cite{reynolds2015counterexample}.
As a result, the problem has been well-studied for the area of propositional specifications (see Gulwani~\cite{gulwani2010dimensions} for a survey), and approaches have been proposed to tackle challenges involving richer specifications. Template-based techniques focus on synthesizing programs that match a certain shape (the template)~\cite{srivastava2013template}, while {\em inductive synthesis} uses the idea of refining the problem space using counterexamples, to converge to a solution~\cite{flener2001inductive}. A different category is that of \textit{functional synthesis}, in which the goal is to construct functions from pre-defined input/output relations~\cite{kuncak2013functional}.

Our goal is to effectively synthesize programs from safety specifications written in the Lustre~\cite{lustrev6} language.  These specifications are structured in the form of {\em Assume-Guarantee} contracts, similarly to approaches in Linear Temporal Logic~\cite{ringert2017synthesis}.

Initially, we present a solution to the synthesis problem which is based on $k$-induction~\cite{gacek2015towards,katis2016towards}. Despite showing good results, the approach suffers from soundness problems with respect to unrealizable results; a contract could be declared as unrealizable, while an actual implementation exists. To combat this soundness issue, we developed a novel approach based on the idea of discovering greatest fixpoints. The approach is a direct improvement over the $k$-inductive method in two important aspects: performance and generality.  On all models that can be synthesized by $k$-induction, the new algorithm always outperforms in terms of synthesis time while yielding roughly approximate code sizes and execution times for the generated code. More importantly, the fixpoint algorithm can synthesize a strictly larger set of benchmark models, and comes with an improved termination guarantee: unlike in $k$-induction, if the algorithm terminates with an ``unrealizable'' result, then there is no possible realization of the contract.

Both techniques have been used to synthesize contracts involving linear real and integer arithmetic (LIRA), but remain generic enough to be extended into supporting additional theories in the future, as well as to liveness properties that can be reduced to safety properties (as in $k$-liveness~\cite{claessen2012liveness}).  Another important attibute that they share is that they are completely automated and require no guidance to the tools in terms of user interaction (unlike~\cite{ryzhyk2014user,ryzhyk2016developing}), being capable of providing solutions without requiring any templates, as in e.g., work by Beyene et. al.~\cite{beyene2014constraint}.  We were able to automatically solve problems that were ``hard'' and required hand-written templates specialized to the problem in~\cite{beyene2014constraint}.

The main idea behind the two algorithms was inspired by induction-based model checking. For the first algorithm we use a quantified variant of k-induction using $\forall\exists$-formulas that can be checked by any SMT solver that supports quantification. Notionally, it checks whether a sequence of states that satisfy the contract of depth is sufficient to guarantee the existence of a successor state that complies with the contract, given an arbitrary input. An outer loop of the algorithm increases until either a solution or counterexample is found. The fixpoint algorithm is inspired by work on IC3 / Property Directed Reachability (PDR)~\cite{bradley2011sat,een2011efficient}. In PDR, the goal is to discover an inductive invariant for a property, by recursively blocking generalized regions describing unsafe states. Similarly, we attempt to reach a greatest fixpoint that contains states that react to arbitrary environment behavior and lead to states within the fixpoint that comply with all guarantees. Formally, the greatest fixpoint is sufficient to prove the validity of a $\forall\exists$-formula, which states that for any state and environment input, there exists a system reaction that complies with the specification. Starting from the entire problem space, we recursively block regions of states that violate the contract, using \textit{regions of validity} that are generated by invalid $\forall\exists$-formulas. If the refined $\forall\exists$-formula is valid, we reach a fixpoint which can effectively be used by the specified transition relation to provide safe reactions to environment inputs. Given a k-inductive proof, or a computed greatest fixpoint we then extract a witness that can be directly transformed into the language intended for the system's implementation.

The algorithms were implemented as features in the \jkind model checker~\cite{gacek2018jk}. For validity checks, as well as witness extraction we use the \aeval Skolemizer~\cite{fedyukovich2015automated}. More specifically, for the fixpoint algorithm we also take advantage of its capability to generate \textit{regions of validity} from invalid formulas.
The contributions of the paper are therefore:
\begin{itemize}
    \item Two novel approaches to synthesis of contracts involving rich theories that are efficient and completely automated (no reliance on templates or user guidance),
    \item an implementation of the approaches in a branch of the \jkind model checker, and
    \item an experiment over a large suite of benchmark models that establish a definitive comparison between the two approaches.
\end{itemize}

The rest of the paper is organized as follows. Sect.~\ref{sec:example} briefly describes the Cinderella-Stepmother problem that we use as an example throughout the paper. In Sect.~\ref{sec:background}, we provide the necessary formal definitions to describe the synthesis algorithms, which are presented then in Sect.~\ref{sec:kinductionsynth} and Sect.~\ref{sec:fixpointsynth}. We present an evaluation in Sect.~\ref{sec:impl} where we compare the two algorithms. Finally, we discuss the differences of our work with closely related ideas in Sect.~\ref{sec:related} and conclude in Sect.~\ref{sec:conclusion}.