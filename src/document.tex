%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[10pt,conference]{llncs}

%to handle ranges of citations in IEEEtran
\usepackage[noadjust]{cite}
\renewcommand{\citepunct}{,\penalty\citepunctpenalty\,}
\renewcommand{\citedash}{--}% optionally

%To fix ``fi'' encoding
\usepackage{cmap}
%\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{courier}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
%--- Return lines start in a new line
\let\oldReturn\Return
\renewcommand{\Return}{\State\oldReturn}
%---
\usepackage[table,xcdraw]{xcolor}
\usepackage{float}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage[]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{placeins}
\usepackage{amsmath,amssymb}
\usepackage{xspace}
\usepackage[font=footnotesize]{caption}
\captionsetup[table]{skip=10pt}
%to solve the hyperref problem of jumping to wrong places
%\usepackage[all]{hypcap}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{booktabs}
\usepackage{fancyvrb}
\usepackage{relsize}
\graphicspath{{images/}}

%\usepackage[ruled,shortend,linesnumbered,algo2e]{algorithm2e}  % algo2e = use \begin{algorithm2e}
\usepackage{float}
\usepackage{subfig}
\usepackage{framed}
\usepackage{multirow}

%TACAS artifact badge
%\usepackage[firstpage]{draftwatermark}
%\SetWatermarkText{\hspace*{6in}\raisebox{6.3in}{\includegraphics[scale=0.1]{aec-badge-tacas}}}
%\SetWatermarkAngle{0}

%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}{Lemma}
%\newtheorem{corollary}{Corollary}

\newcommand{\aeval}{\textsc{AE-VAL}\xspace}
\newcommand{\jkind}{\textsc{JKind}\xspace}

\newcommand{\jsyn}{\textsc{JSyn}\xspace}

\newcommand{\jsynvg}{\textsc{JSyn-vg}\xspace}
% \newcommand{\jsynvg}{\textsc{Jvgs}\xspace}
\newcommand{\smtlibtoc}{\textsc{SMTLib2C}\xspace}
\newcommand{\lustrev}{\textsc{LustreV6}\xspace}

\newcommand{\isSat}{\textsc{isSat}\xspace}
\newcommand{\isUnSat}{\textsc{isUnsat}\xspace}

\iffalse
\newcommand{\viable}{{\mathsf {Viable}}}
\newcommand{\reachable}{{\mathsf {Reachable}}}
\newcommand{\extendable}{{\mathsf {Extend_{n}(s)}}}
\newcommand{\extendablek}{{\mathsf {Extend_{k}(s)}}}

\newcommand{\extend}{{\mathsf {Extend}}}
\newcommand{\basecheck}{{\mathsf {BaseCheck}}}
\newcommand{\extendcheck}{{\mathsf {ExtendCheck}}}
\fi

\newcommand{\viable}{{\mathit {Viable}}}
\newcommand{\reachable}{{\mathit {Reachable}}}
\newcommand{\extendable}{{\mathit {Extend_{n}(s)}}}
\newcommand{\extendablek}{{\mathit {Extend_{k}(s)}}}

\newcommand{\extend}{{\mathit {Extend}}}
\newcommand{\basecheck}{{\mathit {BaseCheck}}}
\newcommand{\extendcheck}{{\mathit {ExtendCheck}}}

\newcommand{\glb}{\textit {GLB}\xspace}
\newcommand{\lub}{\textit {LUB}\xspace}
\newcommand{\tuple}[1]{\langle #1 \rangle}

\renewcommand{\labelitemi}{\tiny$\blacksquare$}

\newcommand{\andreas}[1]{\textcolor{blue}{Andreas: #1}}
\newcommand{\mike}[1]{\textcolor{red}{Mike: #1}}
\newcommand{\andrew}[1]{\textcolor{green}{Andrew: #1}}
\newcommand{\john}[1]{\textcolor{orange}{John: #1}}
\newcommand{\grigory}[1]{\textcolor{brown}{Grigory: #1}}
\newcommand{\arie}[1]{\textcolor{purple}{[Arie: #1]}}
\newcommand{\huajun}[1]{\textcolor{yellow}{[Huajun: #1]}}

\newcommand{\realizable}{\textsc{realizable}\xspace}
\newcommand{\unrealizable}{\textsc{unrealizable}\xspace}
\newcommand{\skolems}{\textit{Skolem}}
\newcommand{\aevalres}{\textit{aevalResult}}
\newcommand{\init}{\textit{init}}
\newcommand{\subs}{\textit{validRegion}}
\newcommand{\isValid}{\textsc{isValid}\xspace}
\newcommand{\isInvalid}{\textsc{isInvalid}\xspace}
%\newcommand{\isSat}{\textsc{isSat}\xspace}
\newcommand{\isUnsat}{\textsc{isUnsat}\xspace}

\newcommand\eqdef{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny def}}}{=}}}

\newcounter{template}

\makeatletter
\newenvironment{template}[1][htb]{%
    \renewcommand{\ALG@name}{Template}% Update algorithm name
   \begin{algorithm}[#1]%
  }{\end{algorithm}}
\makeatother

\newenvironment{requirement}
{\vspace{0.05in}
 \begin{mdframed}[roundcorner=10pt,backgroundcolor=gray!20]}
{\end{mdframed}}

\begin{document}
\title{Algorithms for the Synthesis of Reactive Systems from Assume-Guarantee Contracts}
\andreas{TODO : Update author and contact information}
\andreas{TODO : Cite Grigory's VMCAI paper on AE-VAL}
\author{Andreas Katis\inst{1}, Grigory Fedyukovich\inst{2}, Huajun Guo\inst{1},
  %Andrew Gacek\inst{3},
  John Backes\inst{3}, Arie Gurfinkel\inst{4}, Michael W. Whalen\inst{1}}%
 
\institute{
Department of Computer Science and Engineering, University of Minnesota\\
\email{\{katis001,guoxx663\}@umn.edu, whalen@cs.umn.edu}
\and
Department of Computer Science, Princeton University\\
\email{grigoryf@cs.princeton.edu}
\and
Rockwell Collins Advanced Technology Center\\
\email{\{
%andrew.gacek,
john.backes\}@rockwellcollins.com}
\and
Department of Electrical and Computer Engineering, University of Waterloo\\
\email{agurfinkel@uwaterloo.ca}
}

%\author{\IEEEauthorblockN{Authors anonymized for submission to ASE}}


\maketitle

\begin{abstract}
Automated synthesis of reactive systems from specifications has been a topic of research for decades.  Recently, a variety of approaches have been proposed to extend synthesis of reactive systems from propositional specifications towards specifications over rich theories.
In this paper, we present two novel, template-free approaches to program synthesis which reduce the problem to deciding the validity of a set of $\forall\exists$-formulas, essential to proving the realizability of the given specification.
The first approach constructs such a proof following the k-induction principle, but is inherently not sound with respect to unrealizable results, where a realizable specification might be flagged as non-implementable. The second approach tackles this flaw, attempting to discover a greatest fixpoint of safe reactions, by recursively blocking regions of violating states. For the case of realizable results, if a proof (fixpoint) is found, we construct a correct-by-design witness that is directly translated into an implementation.
We implemented the algorithms as auxiliary features on top of the \jkind model checker, and exercised it against contracts written using the Lustre specification language.
While the fixpoint approach solves the soundness introduced by k-induction, experimental results demonstrate how it also outperforms the latter in relevant raw metrics.
\end{abstract}

\input{intro}
\input{background}
\input{kinductionsynth}
\input{fixpointsynth}
\input{impl}
\input{results}
\input{related}
\input{conclusion}
%\input{artifact}

%\subsubsection*{\textbf{Acknowledgments}}
%This work was funded by DARPA and AFRL under contract FA8750-12-9-0179 (Secure
% Mathematically-Assured Composition of Control Models), and by NASA under contract NNA13AA21C (Compositional Verification of Flight Critical Systems), and by NSF under grant CNS-1035715 (Assuring the safety, security, and reliability of medical device cyber physical systems).
% \IEEEtriggeratref{25}
\bibliography{document}
\bibliographystyle{splncs03}
\end{document}
